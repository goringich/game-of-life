
Задача - написать программу для "симуляции" жизни океана.
Океан - двумерное пространство NxM (N и M задаются пользователем как параметры командной строки при запуске программы).
Каждая клетка океана может содержать объект, либо быть пустой.
Океан - "бесконечен", верх соединен с низом, левая сторона с правой.
Изначальная конфигурация океана определяется случайным образом.
Каждый вид существа должен быть обозначен своим символом.
Каждую итерацию "жизни" океана необходимо выводить на экран.
Программа должна завершаться самостоятельно, если симуляция зашла в тупик (ничего не меняется на протяжении длительного времени)

Ниже будут приведены некоторые наброски кода, которые хотелось бы увидеть в ваших работах.
Естественно, ваши классы и методы будут намного больше.

Простейший класс океана может выглядеть как-то так:
```
    /**
    * Хранит все наши объекты в двумерном пространстве N * M
    * Является "драйвером" для всех объектов (вызывает tick для них, на каждой итерации)
    */
    struct Ocean final {
        using Cell = ...;

        Ocean(size_t r, size_t c)
            : rows{r}, cols{c}, data{r * c}
        {}

        Neighbourhood generate_neighbourhood(size_t i, size_t j, size_t r) {
            /* code */
        }

        void tick() { /* code */ }

    private:
        size_t rows, cols;
        std::vector<Cell> data;
    };
```

Дальше рассмотрим возможные объекты:

    Обозначим некоторые понятия - 
         "рядом", "по-соседству", "в радиусе" - все означает одно и то же - это клетки находящиеся в радиусе интереса объекта
         (радиус интереса может, например, определяться скоростью, или может быть задан параметром)

         "N +- rand" - означает, что N это некий параметр, но может варьироваться в определенных значениях
         например, для каждого класса задается свой N - "среднее время жизни",
         но у конкретных объектов этого класса это значение может быть чуть меньше или больше.
         То, насколько оно меньше или больше задается рандомно при создании объекта.
         Величина рандома должна как-то соотноситься с N. (Было бы странно, если одна рыба должна прожить 10 лет, а вторая 1000)

         "скорость" - количество клеток которое может пройти существо за ход.

    Ваша симуляция должна включать следующие объекты (но не ограничиваться ими):

    Stone
         Камень. Просто камень.
         Через N +- rand итераций может превратиться в коралловый риф.

    Reef
         Коралловый риф. 
         Предоставляет укрытие от хищников.
         Если на соседней клетке от Prey есть коралл, то Prey не может быть съеден.
         Может умереть через N +- rand циклов превратившись в камень.

    Prey
         Добыча.
         Бедное существо, вынужденное прятаться от хищников и размножаться когда получится.
         Скорость - 1 клетка.
         Если рядом есть Predator или ApexPredator, то движется в противоположную ему сторону.
         Взрослеет через N +- rand итераций.
         Умирает через M +- rand итераций. (M > N)
         Если Prey "взрослый"
             и на соседней клетке есть еще один "взрослый" Prey
             и в радиусе нет хищников то =>
         на любой свободной клекте по-соседству рождается новый Prey.
         Время жизни новорожденного должно расчитываться из максимальных времен жизни родителей (+ рандом). Поиграем в эволюцию? :)

    Predator
         Хищник.
         Тот, кто ест бедных Prey.
         Скорость когда сыт - 1 клетка.
         Если рядом есть ApexPredator, то движется в противоположную ему сторону.
         Взрослеет через N +- rand итераций.
         Умирает через M +- rand итераций (M > N), НО может умереть, если пробыл голодным слишком долго (еще один параметр)
         Если хищник становится голодным, то его скорость увеличивается до 2 клеток, пока он не умрет от голода, или не поест.
         Если Predator "взрослый" 
             и на соседней клетке есть еще один "взрослый" Predator
             и оба Predator сытые
             и в радиусе нет старших хищников то =>
         на любой свободной клекте по-соседству рождается новый Predator. Время жизни новорожденного должно расчитываться из максимальных времен жизни родителей.

    ApexPredator
         Высший хищник. Машина для убийств, высшее звено пищевой цепи.
         Скорость когда сыт - 1 клетка.
         Взрослеет через N +- rand итераций.
         Умирает через M +- rand итераций (M > N), НО может умереть, если пробыл голодным слишком долго (еще один параметр)
         Если становится голодным, 
             то через несколько итераций его скорость увеличивается до 2 клеток, пока он не съест Prey
             если за это время Prey не нашлось, то скорость увеличивается до 3 клеток, и теперь он может есть как Prey так и Predator (но не ApexPredator)
             если никого не съел, то умирает
         Если ApexPredator "взрослый" 
             и на соседней клетке есть еще один "взрослый" ApexPredator
             и оба ApexPredator сытые =>
         на любой свободной клекте по-соседству рождается новый ApexPredator. Время жизни новорожденного должно расчитываться из максимальных времен жизни родителей.


    В случае, если существу нечего делать (ни от кого не убегает, не размножается, сытый),
     то он выполняет движение в случайную сторону. Стоять на месте мы не можем (если мы не камень, конечно).

    Конкретных значений для параметров не задано, идея задания в том, что бы попробовать различные конфигурации и посмотреть, как они влияют на симуляцию.
    Действуйте исходя из логики (очевидно, что коралл живет дольше, чем рыба)
    В идеале - подобрать их таким образом, что бы симуляция находилась в равновесии (или в гармонических колебаниях).

    Добавление своих объектов в иерархию или расширение поведения заданных только приветствуется и будет большим плюсом при проверке.
    (Можно добавить еще существ, или класс, разграничивающий живых и неживых, случайные природные явления, уничтожающие всех в опредленном месте океана? Экспереминтируйте :)


Базовый класс для всех объектов может начинаться как-то так:
```
    /**
    * Базовый класс для всех объектов, которые могут находиться в океане
    */
    struct Object {
        // Не забываем про виртуальный деструктор, ведь это базовый класс
        virtual ~Object() = default;

        /**
         * Каждый объект в иерархии должен что-то делать на каждый "такт" жизни
         * На входе - объект представляющий "соседей" (объекты в определенном радиусе интереса, радиус интереса свой для каждого живого существа)
         * При этом объект не должен напрямую влиять на океан (изменять объект Neighbourhood или то, что в нем находится)
         * Возвращает абстрактое "Действие" (описано ниже) которое должно быть совершенно, исходя из окружения объекта
         */
        virtual Action* tick(const Neighbourhood& n) = 0;

        /* 
        * ...
        * Тут могут быть ваши функции и поля, которые вы придумаете сами
        * ...
        */
    };
```

Пример объекта:
```
    /**
     * Самый простой пример - камень
     * (не так прост, на самом деле, если прочесть описание)
     */
    struct Stone : public Object {
        Stone() { /* code */ }

        Action* tick(const Neighbourhood&) override {
            return new NoAction{this};
        }
    };
```

В океане можно производить различные действия (двигаться, есть, умирать)
Все они различны, но по своей сути имеют общую цель - воздействовать на океан.
Отсюда рождается интерфейс для базового класса всех действий:
```
    /**
    * Базовый класс для всех возможных действий, производимых над объектами
    */
    struct Action {
        Action(Object* obj)
            : obj{obj} {}

        virtual ~Action() = default;

        // Пусть Action будет вести себя как функция, которую можно применить к нашему полю Ocean
        // Эта функция не виртуальная, но внутри себя будет вызывать метод наследника
        bool operator()(Ocean& f) { apply(f); }

    protected:

        // Тут сохранен объект над которым происходит действие
        Object* obj;

    private:

        // Тут в классе-наследнике реализуется функционал
        // Возращаем true, если действие удалось сделать,
        //   иначе - false (например, мы хотим двигаться на клетку, которая уже занята, в таком случае движение невозможно)
        virtual bool apply(Ocean&) const = 0;

        /* 
        * ...
        * Тут могут быть ваши функции и поля, которые вы придумаете сами
        * ...
        */
    };
```

Несколько примеров:
```
    /**
     * Самый простой пример действия - бездействие
     */
    struct NoAction : public Action {
        NoAction(Object* obj) : Action{obj} {}
        bool apply(Ocean&) const { /* do literally nothing */ return true; };
    };

    /**
    * Еще пример - движение
    */
    struct Move : public Action {
        enum class Direction { N, S, W, E };

        // count - количество клеток на которое мы сдвигаемся
        // direction - направление
        Move(Object* obj, size_t count, Direction d)
            : Action{obj} {}

        bool apply(Ocean&) const {
            /* your code */
        };
    };

    /**
     * Еще интересный пример - комбинация нескольких действий ("сдвинуться" и "съесть", например)
     */
    struct Combine : public Action {

        bool apply(Ocean&) const {
            /* your code */
        };
    };
```

P.S.
    С началом использования наследования появляется много "сырых" указателей.
    Которые требуют (умственных) усилий для их контроля (знать кто им владеет, когда вызвать delete и так далее).
    Поэтому крайне рекомендуется использовать smart pointer'ы в этой лабе (std::unique_ptr, std::shared_ptr, std::weak_ptr).
    Тема сама по себе не очень большая, поэтому остается на домашнее изучение.
    Дам только небольшую рекомендацию, как их получше использовать:
```
    // хорошей практикой будет задавать алиас для указателей на ваши классы.
    using PreyPtr = std::shared_ptr<struct Prey>;
    struct Prey : public Object {

        // также для удобства можно использовать статическую функцию для создания указателей
        static PreyPtr create(/* args */) {
            return PreyPtr{new Prey{/* args */}};
        }
    };
```